/*
 * Alunos: Lucas Jacques e Lucas Vieira
 * Implementação de uma árvore AVL utilizando alocação dinâmica de memória.
 * 
 * Obs:
 * Foram encontrados muitos problemas na implementação relacionados a "Null Pointer Exception"
 * e "Stack Overflows" principalmente devido a grande utilização de recursão. Os métodos de rotação
 * foram os mais difíceis de implementar, foi necessário buscar códigos prontos para tentar entender
 * como deve ser feito. 
 * 
 * Principal fonte de pesquisa:
 * 	http://www.blackbam.at/blackbams-blog/2012/05/04/avl-tree-implementation-in-java/
 */

public class ArvoreAVL {
	
	//raiz da ArvoreAVL
	private NodoAVL raiz;

	/*
	 * Contrutor da ArvoreAVL
	 * Seta a raiz da arvore como null 
	 */
	public ArvoreAVL() {
		raiz = null;
	}
	
	/*
	 * Busca na ArvoreAVL
	 * Recebe um inteiro e retorna um boolean da busca na ArvoreAVL
	 */
	public boolean busca(int buscado) {
		return busca(raiz, buscado);
	}
	
	/*
	 * Busca na ArvoreAVL
	 * Recebe um NodoAVL e um inteiro buscado
	 * Retorna true caso o inteiro esteja na árvore que 
	 * possui como raiz o NodoAVL recebido e false caso o contrário 
	 */
	private boolean busca(NodoAVL nodo, int buscado) {
		if(nodo == null) {
			return false;
		}
		if(nodo.codigo == buscado) {
			return true;
		} else if(nodo.codigo > buscado) {
			return busca(nodo.esquerda, buscado);
		} else {
			return busca(nodo.direita, buscado);
		}
	}
	
	/*
	 * Recebe um inteiro e insere um NodoAVL na ArvoreAVL
	 */
	public void inserir(int novo) {
		inserir(raiz, new NodoAVL(novo));
	}

	/*
	 * Recebe dois NodoAVL, o primeiro é um pai e o 
	 * segundo um nodo a ser inserido na subarvore que possui como raiz esse pai.  
	 */
	private void inserir(NodoAVL pai, NodoAVL novo) {
		if (pai == null) {
			raiz = novo;
		} else {
			if (novo.codigo > pai.codigo) {
				if (pai.direita == null) {
					pai.direita = novo;
					novo.pai = pai;
					//Nodo inserido, balancear
					balanceia(pai);
				} else {
					inserir(pai.direita, novo);
				}
			} else if (novo.codigo < pai.codigo) {
				if (pai.esquerda == null) {
					pai.esquerda = novo;
					novo.pai = pai;
					//Nodo inserido, balancear					
					balanceia(pai);
				} else {
					inserir(pai.esquerda, novo);
				}
			}
		}
	}
	
	/*
	 * Recebe um NodoAVL e balanceia a ArvoreAVL que ele é raiz
	 */
	private void balanceia(NodoAVL atual) {
		if (atual == null) {
			return;
		}
		//calcula fator de balanceamento do NodoAVL
		atual.fatorB = calculaFatorB(atual);
		if (atual.fatorB == -2) {
			//ArvoreAVL desbalanceada para direita
			if(atual.direita.fatorB <= 0) {
				//ArvoreAVL desbalanceada em "Zig-Zig" rotação simples
				if (atual == raiz) {
					raiz = rotacaoEsquerda(atual);
				} else {
					atual = rotacaoEsquerda(atual);
				}
			}else {
				//ArvoreAVL desbalanceada em "Zig-Zag" rotação dupla
				atual = rotacaoDireitaEsquerda(atual);
			}
		} else if (atual.fatorB == 2) {
			//ArvoreAVL desbalanceada para esquerda
			if (atual.esquerda.fatorB >= 0) {
				//ArvoreAVL desbalanceada em "Zig-Zig" rotação simples
				if (atual == raiz) {
					raiz = rotacaoDireita(atual);
				} else {
					atual = rotacaoDireita(atual);
				}
			} else {
				//ArvoreAVL desbalanceada em "Zig-Zag" rotação dupla
				atual = rotacaoEsquerdaDireita(atual);
			}
		} else {
			//NodoAVL não está desbalanceado, balancear pai
			balanceia(atual.pai);
		}
	}

	/*
	 * Recebe a raiz de uma subárvore desbalanceada e faz
	 * um giro para a direita
	 * Retorna a raiz da nova subarvore, agora balanceada
	 */
	private NodoAVL rotacaoDireita(NodoAVL raizVelha) {
		NodoAVL novaRaiz = raizVelha.esquerda;
		novaRaiz.pai = raizVelha.pai;
		raizVelha.esquerda = novaRaiz.direita;
		if (raizVelha.esquerda != null) {
			raizVelha.esquerda.pai = raizVelha;
		}
		novaRaiz.direita = raizVelha;
		raizVelha.pai = novaRaiz;
		if (novaRaiz.pai != null) {
			if (novaRaiz.pai.direita == raizVelha) {
				novaRaiz.pai.direita = novaRaiz;
			} else if (novaRaiz.pai.esquerda == raizVelha) {
				novaRaiz.pai.esquerda = novaRaiz;
			}
		}
		raizVelha.fatorB = calculaFatorB(raizVelha);
		novaRaiz.fatorB = calculaFatorB(novaRaiz);
		return novaRaiz;
	}

	/*
	 * Recebe a raiz de uma subárvore desbalanceada e faz
	 * um giro para a esquerda
	 * Retorna a raiz da nova subarvore, agora balanceada
	 */
	private NodoAVL rotacaoEsquerda(NodoAVL raizVelha) {
		NodoAVL novaRaiz = raizVelha.direita;
		novaRaiz.pai = raizVelha.pai;
		raizVelha.direita = novaRaiz.esquerda;
		if (raizVelha.direita != null) {
			raizVelha.direita.pai = raizVelha;
		}
		novaRaiz.esquerda = raizVelha;
		raizVelha.pai = novaRaiz;
		if (novaRaiz.pai != null) {
			if (novaRaiz.pai.esquerda == raizVelha) {
				novaRaiz.pai.esquerda = novaRaiz;
			} else if (novaRaiz.pai.direita == raizVelha) {
				novaRaiz.pai.direita = novaRaiz;
			}
		}
		raizVelha.fatorB = calculaFatorB(raizVelha);
		novaRaiz.fatorB = calculaFatorB(novaRaiz);
		return novaRaiz;
	}

	/*
	 * Recebe a raiz de uma subárvore desbalanceada em "Zig-Zag",
	 * faz um giro para a esquerda na subárvore imediata a essa subarvore.
	 * Retorna a rotacao para a direita da subárvore desbalanceada agora em "Zig-Zig"
	 */
	private NodoAVL rotacaoEsquerdaDireita(NodoAVL raizVelha) {
		raizVelha.esquerda = rotacaoEsquerda(raizVelha.esquerda);
		return rotacaoDireita(raizVelha);
	}

	/*
	 * Recebe a raiz de uma subárvore desbalanceada em "Zig-Zag",
	 * faz um giro para a direita na subárvore imediata a essa subarvore.
	 * Retorna a rotacao para a esquerda da subárvore desbalanceada agora em "Zig-Zig"
	 */
	private NodoAVL rotacaoDireitaEsquerda(NodoAVL raizVelha) {
		raizVelha.direita = rotacaoDireita(raizVelha.direita);
		return rotacaoEsquerda(raizVelha);
	}

	/*
	 * Recebe um NodoAVL
	 * Calcula a altura desse NodoAVL recursivamente
	 * Retorna a altura
	 */
	private int calculaAltura(NodoAVL nodo) {
		if (nodo == null) {
			return -1;
		}
		if (nodo.esquerda == null && nodo.direita == null) {
			return 0;
		} else if (nodo.esquerda == null) {
			return 1 + calculaAltura(nodo.direita);
		} else if (nodo.direita == null) {
			return 1 + calculaAltura(nodo.esquerda);
		} else {
			return 1 + Math.max(calculaAltura(nodo.esquerda),
					calculaAltura(nodo.direita));
		}
	}
	
	/*
	 * Recebe um NodoAVL
	 * Calcula as alturas dos filhos
	 * Retorna a diferença das alturas como fator de balanceamento
	 */
	private int calculaFatorB(NodoAVL nodo) {
		int alturaEsquerda = calculaAltura(nodo.esquerda);
		int alturaDireita = calculaAltura(nodo.direita);
		return alturaEsquerda - alturaDireita;
	}

	/*
	 * Método utilizado para "printar" a arvore em pre-order e poder
	 * reconstrui-la verificando se os balanceamentos funcionaram
	 * como esperado
	 */
	public void printPreOrder() {
		printPreOrder(raiz);
	}

	/*
	 * Método que "printa" os NodoAVL's em pre-order recursivamente
	 */
	private void printPreOrder(NodoAVL nodo) {
		if (nodo != null) {
			System.out.printf(nodo.codigo + " ");
			printPreOrder(nodo.esquerda);
			printPreOrder(nodo.direita);
		}
	}

	public static void main(String[] args) {
		ArvoreAVL avl = new ArvoreAVL();
		for(int i = 0; i < 30; i++) {
			System.out.printf(i + " ");
			avl.inserir( (int) (Math.random() * 100));
		}
		System.out.println();
		avl.printPreOrder();
		System.out.println();
		System.out.println(avl.busca(40));
	}
}